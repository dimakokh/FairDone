<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>FireKiosk — Показ заказов</title>

<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<style>
:root{
  --bg:#0e0e0e;
  --text:#ffffff;
  --card:#151515;
  --border:#222;
  --cook:#c62828;
  --ready:#2e7d32;
}

body.light{
  --bg:#f4f4f4;
  --text:#111;
  --card:#ffffff;
  --border:#ddd;
  --cook:#ff5252;
  --ready:#4caf50;
}

html,body{
  margin:0;
  height:100%;
  background:var(--bg);
  color:var(--text);
  font-family:Inter,system-ui;
}

.app{
  height:100%;
  display:flex;
  flex-direction:column;
}

header{
  display:flex;
  align-items:center;
  gap:14px;
  padding:16px 24px;
  border-bottom:1px solid var(--border);
}

#logo{
  width:48px;
  height:48px;
  cursor:pointer;
  /* placeholder visual for logo */
  background: linear-gradient(135deg,#ff7043,#c62828);
  border-radius:8px;
}

.board{
  flex:1;
  display:grid;
  grid-template-columns:1fr 1fr;
}

.column{
  display:flex;
  flex-direction:column;
}

.column-header{
  text-align:center;
  padding:14px;
  font-weight:800;
  font-size:18px;
  color:#fff;
}

.cooking .column-header{ background:var(--cook); }
.ready .column-header{ background:var(--ready); }

.list{
  flex:1;
  align-content: start;
  padding:20px;
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(160px,1fr));
  gap:16px;
}

.order{
  background:var(--card);
  border-radius:18px;
  height:120px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:36px;
  font-weight:900;
  letter-spacing:3px;
  border:1px solid var(--border);
}

/* STAFF MENU */
#staffMenu{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.75);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:999;
}

#staffBox{
  background:var(--card);
  color:var(--text);
  padding:20px;
  width:360px;
  border-radius:16px;
  border:1px solid var(--border);
}

#staffBox h3{ margin-top:0 }

#staffBox input,
#staffBox button,
#staffBox label{
  width:100%;
  padding:10px;
  margin-bottom:10px;
  border-radius:8px;
  border:1px solid var(--border);
  background:var(--bg);
  color:var(--text);
}

#staffBox button{
  cursor:pointer;
  font-weight:700;
}

#terminalList div{
  display:flex;
  justify-content:space-between;
  margin-bottom:6px;
}
</style>
</head>

<body>
<div class="app">

<header>
  <div id="logo" title="Три клика — персональное меню"></div>
  <div style="font-size:20px;font-weight:800">
    FairDone — твой заказ здесь
  </div>
</header>

<div class="board">
  <div class="column cooking">
    <div class="column-header">Готовится</div>
    <div class="list" id="listCooking"></div>
  </div>

  <div class="column ready">
    <div class="column-header">Готово</div>
    <div class="list" id="listReady"></div>
  </div>
</div>

</div>

<!-- STAFF MENU -->
<div id="staffMenu">
  <div id="staffBox">
    <h3>Персональное меню</h3>

    <label>
      <input type="checkbox" id="themeToggle">
      Светлая тема
    </label>

    <hr>

    <input id="terminalInput" placeholder="ID терминала">
    <button id="addTerminal">Добавить терминал</button>
    <button id="resetTerminals">Reset терминалов</button>

    <div id="terminalList"></div>

    <button id="closeStaff">Закрыть</button>
  </div>
</div>

<script>
/*
  Полная логика:
  - при загрузке берём только orders со статусом 'cooking' (готовые не подгружаем)
  - при child_changed: если статус стал 'ready' (или 'completed'), показываем в Ready, озвучиваем один раз, ставим таймер 2 минуты на локальное удаление
  - если таймер уже есть — не дублируем
  - при перезагрузке все локальные таймеры сбрасываются => готовые которые до этого висели не показываются (т.к. мы их не грузим на init)
  - персональное меню: три клика на логотип — привязка терминалов, сохраняется в localStorage
*/

const listCooking = document.getElementById('listCooking');
const listReady = document.getElementById('listReady');

// Основные хранилища
const orders = new Map();        // key -> orderObject (локальная копия для рендера)
const prevStatus = new Map();    // key -> last known status (для обнаружения переходов)
const readyTimers = new Map();   // key -> timeoutId (удаление через 2 минуты)
const announced = new Set();     // key -> уже озвучивали

// Привязанные терминалы
let terminals = JSON.parse(localStorage.getItem('terminals') || '[]');

// UI элементы staff menu
const themeToggle = document.getElementById('themeToggle');
const savedTheme = localStorage.getItem('theme');
if(savedTheme === 'light'){ document.body.classList.add('light'); themeToggle.checked = true; }
themeToggle.onchange = ()=> {
  if(themeToggle.checked){ document.body.classList.add('light'); localStorage.setItem('theme','light'); }
  else { document.body.classList.remove('light'); localStorage.setItem('theme','dark'); }
};

const logo = document.getElementById('logo');
const staffMenu = document.getElementById('staffMenu');
const terminalInput = document.getElementById('terminalInput');
const addTerminal = document.getElementById('addTerminal');
const resetBtn = document.getElementById('resetTerminals');
const terminalList = document.getElementById('terminalList');
const closeStaff = document.getElementById('closeStaff');

let clicks = 0;
logo.onclick = ()=> {
  clicks++;
  setTimeout(()=> clicks = 0, 450);
  if(clicks === 3){
    renderTerminals();
    staffMenu.style.display = 'flex';
    clicks = 0;
  }
};
closeStaff.onclick = ()=> staffMenu.style.display = 'none';

addTerminal.onclick = ()=>{
  const id = terminalInput.value.trim();
  if(!id) return;
  if(terminals.includes(id)) { terminalInput.value = ''; return; }
  terminals.push(id);
  localStorage.setItem('terminals', JSON.stringify(terminals));
  terminalInput.value = '';
  renderTerminals();
  refresh();
};

resetBtn.onclick = ()=>{
  terminals = [];
  localStorage.removeItem('terminals');
  renderTerminals();
  refresh();
};

function renderTerminals(){
  terminalList.innerHTML = '';
  if(terminals.length === 0){ terminalList.innerHTML = '<div style="opacity:.6">Нет привязанных терминалов</div>'; return; }
  terminals.forEach(t=>{
    const row = document.createElement('div');
    row.textContent = t;
    const del = document.createElement('button');
    del.textContent = '×';
    del.style.marginLeft = '8px';
    del.onclick = ()=>{
      terminals = terminals.filter(x => x !== t);
      localStorage.setItem('terminals', JSON.stringify(terminals));
      renderTerminals();
      refresh();
    };
    row.appendChild(del);
    terminalList.appendChild(row);
  });
}

// Helper: рендер карточки заказа (только цифры)
function renderOrderCard(num){
  const d = document.createElement('div');
  d.className = 'order';
  d.textContent = num;
  return d;
}

// Speak once per firebase key
function speakOrder(key, orderNumber){
  if(!key || announced.has(key)) return;
  announced.add(key); // пометим сразу
  // короткая задержка + звуковой сигнал
  setTimeout(()=>{
    try{
      // beep
      try{
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = 'sine';
        o.frequency.value = 880;
        g.gain.value = 0.06;
        o.connect(g); g.connect(ctx.destination);
        o.start();
        setTimeout(()=>{ o.stop(); ctx.close(); }, 120);
      }catch(_){}

      const utter = new SpeechSynthesisUtterance(`Заказ номер ${orderNumber} готов`);
      utter.lang = 'ru-RU';
      // если синтезатор уже говорит — отложим чуть
      if(speechSynthesis.speaking){
        setTimeout(()=> { try{ speechSynthesis.speak(utter); }catch(e){} }, 420);
      } else {
        try{ speechSynthesis.speak(utter); }catch(e){}
      }
    } catch(e){
      console.warn('TTS error', e);
    }
  }, 140);
}

// очистка таймера ready (если есть)
function clearReadyTimer(key){
  const t = readyTimers.get(key);
  if(t) { clearTimeout(t); readyTimers.delete(key); }
}

// refresh UI: отрисовать cooking + ready (ready только локально когда появился)
function refresh(){
  listCooking.innerHTML = '';
  listReady.innerHTML = '';

  if(terminals.length === 0) return;

  for(const [key, order] of orders.entries()){
    if(!terminals.includes(order.terminalId)) continue;
    // ignore orders that are explicitly waiting_for_cash or rejected
    if(order.status === 'waiting_for_cash' || order.status === 'rejected') continue;

    if(order.status === 'cooking'){
      const card = renderOrderCard(order.orderNumber || key);
      listCooking.appendChild(card);
    } else if(order.status === 'ready' || order.status === 'completed'){
      const card = renderOrderCard(order.orderNumber || key);
      listReady.appendChild(card);
    }
  }
}

/* FIREBASE config */
firebase.initializeApp({
  apiKey: "AIzaSyABvY_6cHonbLvdBj5cYMSheJDLMd_-bNw",
  authDomain: "app-fairpay.firebaseapp.com",
  databaseURL: "https://app-fairpay-default-rtdb.firebaseio.com",
  projectId: "app-fairpay",
  storageBucket: "app-fairpay.firebasestorage.app",
  messagingSenderId: "29576302334",
  appId: "1:29576302334:web:0e559f804bf62c59981faf"
});

const ref = firebase.database().ref('orders');

// Инициализация: подгружаем только cooking (чтобы готовые не восстанавливались после перезагрузки)
(async function initLoad(){
  try{
    const snap = await ref.once('value');
    snap.forEach(child => {
      const key = child.key;
      const val = child.val();
      // сохраняем prevStatus (для отслеживания переходов)
      prevStatus.set(key, val.status);
      // загрузим в память только если статус cooking (по требованию — ready НЕ показываем после reload)
      if(val.status === 'cooking'){
        orders.set(key, val);
      }
    });
    renderTerminals(); // отрисовать список терминалов из localStorage
    refresh();
  } catch(e){
    console.warn('init load failed', e);
  }
})();

// child_added: если сразу пришёл cooking — добавим; если ready — игнорируем (будем обрабатывать transition в child_changed)
ref.on('child_added', snap => {
  const key = snap.key;
  const val = snap.val();
  prevStatus.set(key, val.status);
  if(val.status === 'cooking'){
    orders.set(key, val);
    refresh();
  }
  // если пришёл ready в child_added (редкий кейс) — не показываем его сразу (перезагрузка и т.п.)
});

// child_changed: основной обработчик переходов (включая cooking->ready)
ref.on('child_changed', snap => {
  const key = snap.key;
  const val = snap.val();
  const old = prevStatus.get(key);
  prevStatus.set(key, val.status);

  // Если статус стал ready/complete и раньше он не был ready — показываем и запускаем таймер + озвучку
  const nowIsReady = (val.status === 'ready' || val.status === 'completed');
  const wasReady = (old === 'ready' || old === 'completed');

  if(nowIsReady && !wasReady){
    // Добавим в локальную карту (чтобы показать в Ready)
    orders.set(key, val);
    refresh();

    // Если уже есть таймер/аннонс — не создавать повторно
    if(!announced.has(key) && !readyTimers.has(key)){
      // пометим как анонсируемое и запустим озвучку
      speakOrder(key, val.orderNumber || key);
      // поставить таймер: через 2 минуты скрыть локально
      const t = setTimeout(() => {
        // удаляем только локально с сайта
        orders.delete(key);
        readyTimers.delete(key);
        // если нужно — также можно удалить announced.delete(key) чтобы при новом ключе произнести снова
        refresh();
      }, 120000); // 2 минуты
      readyTimers.set(key, t);
      // отметим announced (speakOrder тоже добавляет, но на всякий случай)
      announced.add(key);
    }
    return;
  }

  // Если статус превратился в cooking (например откат), покажем в cooking
  if(val.status === 'cooking'){
    // очистим готовые таймеры / маркировки, если были
    clearReadyTimer(key);
    announced.delete(key);
    orders.set(key, val);
    refresh();
    return;
  }

  // Другие статусы: обновим/уберём из локального представления в зависимости от логики
  if(val.status === 'waiting_for_cash' || val.status === 'rejected'){
    // скрыть локально
    clearReadyTimer(key);
    orders.delete(key);
    announced.delete(key);
    refresh();
    return;
  }

  // По умолчанию просто обновляем локальную запись и рендерим
  orders.set(key, val);
  refresh();
});

// child_removed: очистим всё, если запись удалили
ref.on('child_removed', snap => {
  const key = snap.key;
  clearReadyTimer(key);
  prevStatus.delete(key);
  orders.delete(key);
  announced.delete(key);
  refresh();
});

// Прочие утилиты (например, если нужно очистить все timers при выгрузке)
window.addEventListener('beforeunload', () => {
  // таймеры не сохраняются намеренно (по требованию) — но чистим ресурсы
  for(const t of readyTimers.values()) clearTimeout(t);
  readyTimers.clear();
});

</script>
</body>
</html>
