<!doctype html>
<html lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>FireKiosk — Показ заказов</title>

<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

<style>
:root{
  --bg:#0e0e0e;
  --text:#ffffff;
  --card:#151515;
  --border:#222;
  --cook:#c62828;
  --ready:#2e7d32;
}

body.light{
  --bg:#f4f4f4;
  --text:#111;
  --card:#ffffff;
  --border:#ddd;
  --cook:#ff5252;
  --ready:#4caf50;
}

html,body{
  margin:0;
  height:100%;
  background:var(--bg);
  color:var(--text);
  font-family:Inter,system-ui;
}

.app{
  height:100%;
  display:flex;
  flex-direction:column;
}

header{
  display:flex;
  align-items:center;
  gap:14px;
  padding:16px 24px;
  border-bottom:1px solid var(--border);
}

#logo{
  width:48px;
  height:48px;
  cursor:pointer;
  /* placeholder visual for logo */
  background: linear-gradient(135deg,#ff7043,#c62828);
  border-radius:8px;
}

.board{
  flex:1;
  display:grid;
  grid-template-columns:1fr 1fr;
}

.column{
  display:flex;
  flex-direction:column;
}

.column-header{
  text-align:center;
  padding:14px;
  font-weight:800;
  font-size:18px;
  color:#fff;
}

.cooking .column-header{ background:var(--cook); }
.ready .column-header{ background:var(--ready); }

.list{
  flex:1;
  align-content: start;
  padding:20px;
  display:grid;
  grid-template-columns:repeat(auto-fill,minmax(160px,1fr));
  gap:16px;
}

.order{
  background:var(--card);
  border-radius:18px;
  height:120px;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:36px;
  font-weight:900;
  letter-spacing:3px;
  border:1px solid var(--border);
}

/* STAFF MENU */
#staffMenu{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,.75);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:999;
}

#staffBox{
  background:var(--card);
  color:var(--text);
  padding:20px;
  width:360px;
  border-radius:16px;
  border:1px solid var(--border);
}

#staffBox h3{ margin-top:0 }

#staffBox input,
#staffBox button,
#staffBox label{
  width:100%;
  padding:10px;
  margin-bottom:10px;
  border-radius:8px;
  border:1px solid var(--border);
  background:var(--bg);
  color:var(--text);
}

#staffBox button{
  cursor:pointer;
  font-weight:700;
}

#terminalList div{
  display:flex;
  justify-content:space-between;
  margin-bottom:6px;
}
</style>
</head>

<body>
<div class="app">

<header>
  <div id="logo" title="Три клика — персональное меню"></div>
  <div style="font-size:20px;font-weight:800">
    FairDone — твой заказ здесь
  </div>
</header>

<div class="board">
  <div class="column cooking">
    <div class="column-header">Готовится</div>
    <div class="list" id="listCooking"></div>
  </div>

  <div class="column ready">
    <div class="column-header">Готово</div>
    <div class="list" id="listReady"></div>
  </div>
</div>

</div>

<!-- STAFF MENU -->
<div id="staffMenu">
  <div id="staffBox">
    <h3>Персональное меню</h3>

    <label>
      <input type="checkbox" id="themeToggle">
      Светлая тема
    </label>

    <hr>

    <input id="terminalInput" placeholder="ID терминала">
    <button id="addTerminal">Добавить терминал</button>
    <button id="resetTerminals">Reset терминалов</button>

    <div id="terminalList"></div>

    <button id="closeStaff">Закрыть</button>
  </div>
</div>

<script>
/*
  Обновлённая логика озвучки:
  - announced: Set в оперативной памяти, хранит ключи firebase (child.key), помеченные как уже озвученные.
  - announced наполняется СИНХРОННО при детектировании перехода из non-ready -> ready (до вызова TTS).
  - announced живёт в памяти страницы и **сбрасывается при перезагрузке** (как ты просил).
  - остальная логика: показать cooking на init, при transition cooking->ready показать в Ready, озвучить один раз, поставить таймер 2 минуты на локальное удаление.
*/

const listCooking = document.getElementById('listCooking');
const listReady = document.getElementById('listReady');

// Основные хранилища
const orders = new Map();        // key -> orderObject (локальная копия для рендера)
const prevStatus = new Map();    // key -> last known status (для обнаружения переходов)
const readyTimers = new Map();   // key -> timeoutId (удаление через 2 минуты)
const announced = new Set();     // key -> уже произнесённые (в ОПЕРАТИВНОЙ памяти — очищается при reload)

// Привязанные терминалы
let terminals = JSON.parse(localStorage.getItem('terminals') || '[]');

// UI элементы staff menu
const themeToggle = document.getElementById('themeToggle');
const savedTheme = localStorage.getItem('theme');
if(savedTheme === 'light'){ document.body.classList.add('light'); themeToggle.checked = true; }
themeToggle.onchange = ()=> {
  if(themeToggle.checked){ document.body.classList.add('light'); localStorage.setItem('theme','light'); }
  else { document.body.classList.remove('light'); localStorage.setItem('theme','dark'); }
};

const logo = document.getElementById('logo');
const staffMenu = document.getElementById('staffMenu');
const terminalInput = document.getElementById('terminalInput');
const addTerminal = document.getElementById('addTerminal');
const resetBtn = document.getElementById('resetTerminals');
const terminalList = document.getElementById('terminalList');
const closeStaff = document.getElementById('closeStaff');

let clicks = 0;
logo.onclick = ()=> {
  clicks++;
  setTimeout(()=> clicks = 0, 450);
  if(clicks === 3){
    renderTerminals();
    staffMenu.style.display = 'flex';
    clicks = 0;
  }
};
closeStaff.onclick = ()=> staffMenu.style.display = 'none';

addTerminal.onclick = ()=>{
  const id = terminalInput.value.trim();
  if(!id) return;
  if(terminals.includes(id)) { terminalInput.value = ''; return; }
  terminals.push(id);
  localStorage.setItem('terminals', JSON.stringify(terminals));
  terminalInput.value = '';
  renderTerminals();
  refresh();
};

resetBtn.onclick = ()=>{
  terminals = [];
  localStorage.removeItem('terminals');
  renderTerminals();
  refresh();
};

function renderTerminals(){
  terminalList.innerHTML = '';
  if(terminals.length === 0){ terminalList.innerHTML = '<div style="opacity:.6">Нет привязанных терминалов</div>'; return; }
  terminals.forEach(t=>{
    const row = document.createElement('div');
    row.textContent = t;
    const del = document.createElement('button');
    del.textContent = '×';
    del.style.marginLeft = '8px';
    del.onclick = ()=>{
      terminals = terminals.filter(x => x !== t);
      localStorage.setItem('terminals', JSON.stringify(terminals));
      renderTerminals();
      refresh();
    };
    row.appendChild(del);
    terminalList.appendChild(row);
  });
}

// Helper: рендер карточки заказа (только цифры)
function renderOrderCard(num){
  const d = document.createElement('div');
  d.className = 'order';
  d.textContent = num;
  return d;
}

// Speak: не модифицируем announced тут — он должен быть помечен ранее, чтобы избежать гонок
function speakOrder(key, orderNumber){
  // safety: если уже помечено как announced — просто вернёмся
  if(announced.has(key)) return;

  // (на всякий случай) пометить и дальше не сделать ничего; но по дизайну мы помечаем раньше, так что это защитный слой
  announced.add(key);

  try{
    // короткая задержка + beep + TTS
    setTimeout(()=>{
      try{
        // beep
        try{
          const ctx = new (window.AudioContext || window.webkitAudioContext)();
          const o = ctx.createOscillator();
          const g = ctx.createGain();
          o.type = 'sine';
          o.frequency.value = 880;
          g.gain.value = 0.06;
          o.connect(g); g.connect(ctx.destination);
          o.start();
          setTimeout(()=>{ o.stop(); ctx.close(); }, 120);
        }catch(_){}

        const utter = new SpeechSynthesisUtterance(`Заказ номер ${orderNumber} готов`);
        utter.lang = 'ru-RU';
        // не даём накапливаться речи: если сейчас идёт — отложим немного
        if(speechSynthesis.speaking){
          setTimeout(()=> { try{ speechSynthesis.speak(utter); }catch(e){} }, 420);
        } else {
          try{ speechSynthesis.speak(utter); }catch(e){}
        }
      } catch(e){
        console.warn('TTS error', e);
      }
    }, 140);
  } catch(e){ console.warn('speakOrder error', e); }
}

// очистка таймера ready (если есть)
function clearReadyTimer(key){
  const t = readyTimers.get(key);
  if(t) { clearTimeout(t); readyTimers.delete(key); }
}

// refresh UI: отрисовать cooking + ready (ready только локально когда появился)
function refresh(){
  listCooking.innerHTML = '';
  listReady.innerHTML = '';

  if(terminals.length === 0) return;

  for(const [key, order] of orders.entries()){
    if(!terminals.includes(order.terminalId)) continue;
    // ignore orders that are explicitly waiting_for_cash or rejected
    if(order.status === 'waiting_for_cash' || order.status === 'rejected') continue;

    if(order.status === 'cooking'){
      const card = renderOrderCard(order.orderNumber || key);
      listCooking.appendChild(card);
    } else if(order.status === 'ready' || order.status === 'completed'){
      const card = renderOrderCard(order.orderNumber || key);
      listReady.appendChild(card);
    }
  }
}

/* FIREBASE config */
firebase.initializeApp({
  apiKey: "AIzaSyABvY_6cHonbLvdBj5cYMSheJDLMd_-bNw",
  authDomain: "app-fairpay.firebaseapp.com",
  databaseURL: "https://app-fairpay-default-rtdb.firebaseio.com",
  projectId: "app-fairpay",
  storageBucket: "app-fairpay.firebasestorage.app",
  messagingSenderId: "29576302334",
  appId: "1:29576302334:web:0e559f804bf62c59981faf"
});

const ref = firebase.database().ref('orders');

// Инициализация: подгружаем только cooking (чтобы готовые не восстанавливались после перезагрузки)
(async function initLoad(){
  try{
    const snap = await ref.once('value');
    snap.forEach(child => {
      const key = child.key;
      const val = child.val();
      prevStatus.set(key, val.status);
      if(val.status === 'cooking'){
        orders.set(key, val);
      }
    });
    renderTerminals();
    refresh();
  } catch(e){
    console.warn('init load failed', e);
  }
})();

// child_added: если сразу пришёл cooking — добавим
ref.on('child_added', snap => {
  const key = snap.key;
  const val = snap.val();
  prevStatus.set(key, val.status);
  if(val.status === 'cooking'){
    orders.set(key, val);
    refresh();
  }
});

// child_changed: обработка переходов (в т.ч. cooking -> ready)
ref.on('child_changed', snap => {
  const key = snap.key;
  const val = snap.val();
  const old = prevStatus.get(key);
  prevStatus.set(key, val.status);

  const nowIsReady = (val.status === 'ready' || val.status === 'completed');
  const wasReady = (old === 'ready' || old === 'completed');

  if(nowIsReady && !wasReady){
    // СИНХРОННО отмечаем как уже произнесённое — чтобы исключить дубли при быстрых нескольких событиях
    if(!announced.has(key)){
      announced.add(key);
    }
    // Добавим в локальную карту (для отображения в Ready)
    orders.set(key, val);
    refresh();

    // Если таймера ещё нет — запускаем локальный таймер на 2 минуты для удаления с UI
    if(!readyTimers.has(key)){
      // озвучка (announce уже помечен)
      speakOrder(key, val.orderNumber || key);

      const t = setTimeout(() => {
        // локально удаляем
        orders.delete(key);
        readyTimers.delete(key);
        // НЕ чистим announced — оно живёт до перезагрузки
        refresh();
      }, 120000);
      readyTimers.set(key, t);
    }
    return;
  }

  // Если переключили обратно в cooking — убираем возможные ready-таймеры/маркировки
  if(val.status === 'cooking'){
    clearReadyTimer(key);
    // не очищаем announced здесь — заказ был озвучен ранее и остаётся в памяти до перезагрузки
    orders.set(key, val);
    refresh();
    return;
  }

  // Если статус waiting_for_cash или rejected — скрываем локально
  if(val.status === 'waiting_for_cash' || val.status === 'rejected'){
    clearReadyTimer(key);
    orders.delete(key);
    // Не очищаем announced (по требованию — очистка только при перезагрузке)
    refresh();
    return;
  }

  // По умолчанию обновляем локальную запись
  orders.set(key, val);
  refresh();
});

// child_removed: очистим всё
ref.on('child_removed', snap => {
  const key = snap.key;
  clearReadyTimer(key);
  prevStatus.delete(key);
  orders.delete(key);
  announced.delete(key); // optional: если запись удалили, можно убрать её из announced
  refresh();
});

// при выгрузке страницы — очистим таймеры (announced останется нет — т.к. память сбрасывается)
window.addEventListener('beforeunload', () => {
  for(const t of readyTimers.values()) clearTimeout(t);
  readyTimers.clear();
});
</script>
</body>
</html>
